\section{ Preliminaries}

\subsection{Fields}

Fields of size $q$ are denoted as $\FFF_q$ or simply $\FFF$. Currently supported prime fields:
\begin{itemize}
    \item KoalaBear: $q=2^{31}-2^{24}+1$
    \item Goldilocks: $q=2^{64}-2^{32}+1$
    \item Mersenne31: $q=2^{31}-1$
    \item BN254: $q=21888242871839275222246405745257275088548364400416034343698204186575808495617$
\end{itemize}

\subsection{Regime-specific bounds}



\subsubsection{Proximity parameter }\label{sec:fri_optimal_distance_udr}\label{sec:fri_optimal_distance_jbr}


\begin{verbatim}unique_decoding.py/get_proximity_parameter()\end{verbatim}

In UDR
\begin{equation}\label{eq:pp_udr}
    \delta_U(\rho) =(1-\rho)/2
\end{equation}


In JBR we compute the $\delta$ differently.

\begin{verbatim}johnson_bound.py/get_proximity_parameter()\end{verbatim}

\begin{equation}\label{eq:pp_jbr}
    \delta_J(\rho,N,q) =\begin{cases}
    1-\sqrt{\rho}-\frac{\sqrt{\rho}}{100}&\quad \text{ if }q>2^{150}\\
    1-\sqrt{\rho}-\max(\frac{\rho}{20},\frac{\sqrt{\rho}}{100})&\quad \text{ otherwise}
    \end{cases}
\end{equation}


\subsubsection{List sizes} \label{sec:fri_list_sizes}
\begin{verbatim}unique_decoding.py/get_max_list_size()\end{verbatim}
$$
\ell = 1
$$

\begin{verbatim}johnson_bound.py/get_max_list_size()\end{verbatim}
We compute
$$
\ell(\rho,N) = \frac{1}{2(1-\sqrt{\rho}-\delta)\sqrt{\rho}}.
$$


\subsubsection{Batching errors}\label{sec:batch}
We define batching error functions
$$
\ebatchpowJ(\rho,N,q,B), \quad \ebatchpowU(\rho,N,q,B),\quad \ebatchlinU(\rho,N,q),\quad \ebatchpowU(\rho,N,q,B)
$$
For JBR :
\begin{itemize}
    \item Compute proximity parameter $\delta$ as in \eqref{eq:pp_jbr}:

    \item Compute $m$ as in \verb|get_m()|:
    $$
    m =0.5+\max\left(\left\lceil\frac{\sqrt{\rho}}{1-\sqrt{\rho}-\delta} \right\rceil,3\right)
    $$
    \item Compute linear error\footnote{Code refers to Theorem 4.2 from BCHKS25}:
    $$
    \ebatchlinJ(\rho,N,q) = \frac{N\left(2m^5+3m\delta\rho\right)+3m\rho}{3\rho^{1.5}q}
    $$
    \item Compute powers error:
    $$
    \ebatchpowJ(\rho,N,q,B) = \ebatchlinJ( \rho,N,q)\cdot(B-1)
    $$
\end{itemize}


For UDR :
\begin{itemize}
    \item Compute linear error:
    $$
    \ebatchlinU(\rho,N,q) = \frac{N}{q\rho}
    $$
    \item Compute powers error:
    $$
    \ebatchpowU(\rho,N,q,B) = \ebatchlinJ( \rho,N,q)\cdot B
    $$

\end{itemize}



\subsubsection{DEEP-ALI errors}\label{sec:fri-deep-ali}
\begin{verbatim}circuit.py/get_DEEP_ALI_errors()\end{verbatim}

The DEEP-ALI soundness error (with exception of the list size) and notation are taken from \cite[Section 5.2]{habock2022summary}:
\begin{itemize}
    \item Number of AIR constraints~\cite[p.15]{habock2022summary}: $C=$ \verb|num_constraints|
    \item Overall AIR degree: $d =$ \verb|AIR_max_degree|
    \item Trace increase constant \cite[Remark 7]{habock2022summary}: $m_c$ \verb|max_combo| (set to 2 in ~\cite{habock2022summary} )
    \item Trace length: $N$ (denoted by $|H|$ in ~\cite{habock2022summary})
    \item List size: $\ell$ as in \cref{sec:fri_list_sizes}, replaces the $L^{+}$ in ~\cite{habock2022summary}
\end{itemize}

The DEEP-ALI soundness error is computed as follows:
\begin{equation}
    \edeep = \max\left(\frac{\ell\cdot C}{2^{\bfield}}, \frac{\ell(d(N+m_c-1)+(N-1))}{2^{\bfield}-N-N/\rho}\right)
\end{equation}
